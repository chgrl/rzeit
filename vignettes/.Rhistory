count_df <- plyr::rename(count_df, c("V1" = "from"))
count_df$to <- as.character(to)
count_df$degree <- as.integer(degree)
count_df <- count_df[count_df$degree > 4, ]
regierung_network <- graph.data.frame(count_df, directed = FALSE)
plot(regierung_network)
regierung_url <- "https://de.wikipedia.org/wiki/Bundesregierung_%28Deutschland%29"
regierung_parsed <- html(regierung_url, encoding = "UTF8")
### read the table
regierung_table <- readHTMLTable(regierung_parsed)
regierung_table <- as.data.frame(regierung_table[1])
regierung_table <- plyr::rename(regierung_table, c("Zusammensetzung.der.Bundesregierung.seit.17..Februar.2014.Ressort.Amt" = "ministry"))
regierung_table <- plyr::rename(regierung_table, c("Zusammensetzung.der.Bundesregierung.seit.17..Februar.2014.Amtsinhaber" = "name"))
regierung_table <- plyr::rename(regierung_table, c("Zusammensetzung.der.Bundesregierung.seit.17..Februar.2014.Partei" = "partei"))
regierung_table[ ,2] <- NULL
regierung_table$ministerium <- as.character(regierung_table$ministry)
regierung_table$name <- as.character(regierung_table$name)
regierung_table$partei <- as.character(regierung_table$partei)
i <- 1
from <- NULL
to <- NULL
degree <- NULL
while (i <= nrow(regierung_table)){
j <- i + 1
while (j <= nrow(regierung_table)){
from <- rbind(from, regierung_table$name[i])
to <- rbind(to, regierung_table$name[j])
degree <- rbind(degree, round(runif(1, min = 1, max = 10)))
j <- j + 1
}
i <- i + 1
}
count_df <- as.data.frame(from, stringsAsFactors = FALSE)
count_df <- plyr::rename(count_df, c("V1" = "from"))
count_df$to <- as.character(to)
count_df$degree <- as.integer(degree)
count_df <- count_df[count_df$degree > 4, ]
regierung_network <- graph.data.frame(count_df, directed = FALSE)
plot(regierung_network)
library(rzeit)
fromZeit(q = "Angela Merkel",
limit = "1000",
split = TRUE)
library(stringr)
library(rzeit)
library(stringr)
library(jsonlite)
fromZeit(q = "Angela Merkel",
limit = "1000",
split = TRUE)
library(lubridate)
fromZeit(q = "Angela Merkel",
limit = "1000",
split = TRUE)
options(zeitApiKey = "40b65e34423ed6cb8d7f05914bbdaa1355f7c650caa8821e95b4")
fromZeit(q = "Angela Merkel",
limit = "1000",
split = TRUE)
options(zeitApiKey = "40b65e34423ed6cb8d7f05914bbdaa1355f7c650caa8821e95b4")
result <- fromZeit(q = "Angela Merkel",
limit = "1000",
split = TRUE)
result <- fromZeit(q = "Spanien",
limit = "1000",
split = TRUE)
# zeitSplitSearch
#
# Allows to split the search in order to cover larger timespans.
#
# @param x url as character
# @param begin Begin date - Restricts responses to results with publication dates of the date specified or later. In the form YYYY-MM-DD
# @param end End date - Restricts responses to results with publication dates of the date specified or earlier. In the form YYYY-MM-DD
#
# @details \code{zeitSplitSearch} limits how many article are returend for each month, so that the search can cover a large timespan, even if one month originally contained an extremly large number of articles.
zeitSplitSearch <- function(x, begin, end, q){
url <- x
dateVector <- seq.Date(from = as.Date(begin), to = as.Date(end), by = "month")
startDate <- dateVector[length(dateVector)]
dateVector[length(dateVector) + 1] <- startDate %m+% months(1)
i <- as.numeric(length(dateVector)) - 1
df <- data.frame(NULL)
lsTest <- fromJSON(x)
if(lsTest$found < 1000){
lsTest$searchURL <- url
lsTest$queryTerm <- q
close(x)
return(lsTest)
close()
} else{
while (i > 0){
replaceDate <- paste("[", as.character(dateVector[i]), "T00:00:00Z TO ", as.character(dateVector[i+1]-1), "T23:59:59.999Z]", sep = "")
x <- str_replace(x, "\\[[[:print:]]{10,}\\]", replaceDate)
x <- str_replace(x, "\\&limit\\=\\d{1,4}", "&limit=1000")
# translate JSON into R Object
y <- fromJSON(x)
# transform into DataFrame
y <- as.data.frame(y[1])
# combine new and latter DataFrame
df <- rbind(df, y)
zeitCounter()
# system sleep
Sys.sleep(1)
close(x)
i <- i - 1
}
}
ls <- list(df)
ls$found <- nrow(df)
ls$returned <- nrow(df)
ls$offset <- lsTest$offset
ls$searchURL <- url
ls$queryTerm <- q
# return matches
return(ls)
}
result <- fromZeit(q = "Spanien",
limit = "1000",
split = TRUE)
result <- fromZeit(q = "Spanien",
library(rzeit)
library(stringr)
library(jsonlite)
library(lubridate)
library(stringr)
library(jsonlite)
library(lubridate)
library(rzeit)
result <- fromZeit(q = "Spanien",
limit = "1000",
split = TRUE)
options(zeitApiKey = "40b65e34423ed6cb8d7f05914bbdaa1355f7c650caa8821e95b4")
result <- fromZeit(q = "Spanien",
limit = "1000",
split = TRUE)
library(stringr)
library(jsonlite)
library(lubridate)
library(rzeit)
options(zeitApiKey = "40b65e34423ed6cb8d7f05914bbdaa1355f7c650caa8821e95b4")
result <- fromZeit(q = "Spanien",
limit = "1000",
split = TRUE)
?cut
browseVignettes("rzeit")
browseVignettes("rzeit")
require(rzeit)
require(stringr)
require(jsonlite)
require(lubridate)
require(rvest)
require(XML)
require(plyr)
require(networkD3)
#### Gathering Data
#In a first step, we gather Wikipedia informations on German ministers. We are using German ministers, beacause ZEIT ONNLINE provides only news articles in German. We parsing a page about the German government and create a data frame with the name and party. Further every person gets a personal ID number.
### Take the table of mps----
regierung_url <- "https://de.wikipedia.org/wiki/Bundesregierung_%28Deutschland%29"
regierung_parsed <- html(regierung_url, encoding = "UTF8")
### read the table
regierung_tables <- readHTMLTable(regierung_parsed)
regierung_df <- as.data.frame(regierung_tables[1])
regierung_df <- rename(regierung_df,
c("Zusammensetzung.der.Bundesregierung.seit.17..Februar.2014.Amtsinhaber" = "name"))
regierung_df <- rename(regierung_df,
c("Zusammensetzung.der.Bundesregierung.seit.17..Februar.2014.Partei" = "partei"))
regierung_df$name <- as.character(regierung_df$name)
regierung_df$partei <- as.character(regierung_df$partei)
regierung_df$number <- 0:15
regierung_df <- regierung_df[, -1]
regierung_df <- regierung_df[, -1]
#Secondly, we build a second data frame with pairs of every name. This data frame will provide our queries for the `fromZeit`-function. Furthermore, we copy the corresponding ID numbers. This will be very important in a further step.
i <- 1
from <- NULL
to <- NULL
while (i <= nrow(regierung_df)){
j <- i + 1
while (j <= nrow(regierung_df)){
from <- rbind(from, regierung_df$name[i])
to <- rbind(to, regierung_df$name[j])
j <- j + 1
}
i <- i + 1
}
count_df <- as.data.frame(from, stringsAsFactors = FALSE)
count_df <- rename(count_df, c("V1" = "from"))
count_df$to <- as.character(to)
count_df$fromNumber <- NA
count_df$toNumber <- NA
i <- 1
while (i <= nrow(count_df)){
j <- 1
while(j <= nrow(regierung_df)){
if (regierung_df$name[j] == count_df$to[i]){
count_df$toNumber[i] <- regierung_df$number[j]
}
j <- j + 1
}
i <- i + 1
}
i <- 1
while (i <= nrow(count_df)){
j <- 1
while(j <= nrow(regierung_df)){
if (regierung_df$name[j] == count_df$from[i]){
count_df$fromNumber[i] <- regierung_df$number[j]
}
j <- j + 1
}
i <- i + 1
}
### Performing the queries and counting
#Thirdly, we perform the actuall queries. We define the API Key. We paste the pairs in the count_df and use them as queries. We set the date to the current period of governance. We set the `limit = 1`, beacause we only intrested in the numbers which are found in the respective period. At last we set the system to sleep for half a second to be server kindly.
options(zeitApiKey = "40b65e34423ed6cb8d7f05914bbdaa1355f7c650caa8821e95b4")
count_df$count <- 0
i <- 1
while (i <= nrow(count_df)){
query = paste(count_df$from[i],
count_df$to[i], sep = " ")
articels <- fromZeit(q = query,
limit = "1",
dateBegin = "2013-02-17",
dateEnd = "2015-04-07")
count_df$count[i] <- count_df$count[i] + as.numeric(articels$found)
Sys.sleep(0.5)
i <- i + 1
}
#In a fourt part, we count the numbers of articles in which every minister is mentioned.
i <- 1
regierung_df$mentioned <- 0
while (i <= nrow(regierung_df)){
j <- 1
while (j <= nrow(count_df)){
regierung_df$mentioned[i] <- ifelse(count_df$from[j] == regierung_df$name[i],
regierung_df$mentioned[i] + count_df$count[j],
regierung_df$mentioned[i])
j <- j + 1
}
i <- i + 1
}
i <- 1
while (i <= nrow(regierung_df)){
j <- 1
while (j <= nrow(count_df)){
regierung_df$mentioned[i] <- ifelse(count_df$to[j] == regierung_df$name[i],
regierung_df$mentioned[i] + count_df$count[j],
regierung_df$mentioned[i])
j <- j + 1
}
i <- i + 1
}
regierung_df$mentioned <- round(regierung_df$mentioned / 100)
### Plot the network
#At last we plot the network. Minimize the connections to improve output quality.
sample <- count_df[count_df$count > mean(count_df$count), ]
forceNetwork(Links = sample,
Nodes = regierung_df,
Source = "fromNumber",
Target = "toNumber",
Value = "count",
NodeID = "name",
Group = "partei",
Nodesize = "mentioned",
linkDistance = JS("function(d){return d.value * 1.5}"),
linkWidth = JS("function(d){return d.value / 50}"),
opacity = 0.8,
width = 800,
height = 400,
legend = TRUE)
require(rzeit)
require(stringr)
require(jsonlite)
require(lubridate)
require(rvest)
require(XML)
require(plyr)
require(networkD3)
#### Gathering Data
#In a first step, we gather Wikipedia informations on German ministers. We are using German ministers, beacause ZEIT ONNLINE provides only news articles in German. We parsing a page about the German government and create a data frame with the name and party. Further every person gets a personal ID number.
### Take the table of mps----
regierung_url <- "https://de.wikipedia.org/wiki/Bundesregierung_%28Deutschland%29"
regierung_parsed <- html(regierung_url, encoding = "UTF8")
### read the table
regierung_tables <- readHTMLTable(regierung_parsed)
regierung_df <- as.data.frame(regierung_tables[1])
regierung_df <- rename(regierung_df,
c("Zusammensetzung.der.Bundesregierung.seit.17..Februar.2014.Amtsinhaber" = "name"))
regierung_df <- rename(regierung_df,
c("Zusammensetzung.der.Bundesregierung.seit.17..Februar.2014.Partei" = "partei"))
regierung_df$name <- as.character(regierung_df$name)
regierung_df$partei <- as.character(regierung_df$partei)
regierung_df$number <- 0:15
regierung_df <- regierung_df[, -1]
regierung_df <- regierung_df[, -1]
#Secondly, we build a second data frame with pairs of every name. This data frame will provide our queries for the `fromZeit`-function. Furthermore, we copy the corresponding ID numbers. This will be very important in a further step.
i <- 1
from <- NULL
to <- NULL
while (i <= nrow(regierung_df)){
j <- i + 1
while (j <= nrow(regierung_df)){
from <- rbind(from, regierung_df$name[i])
to <- rbind(to, regierung_df$name[j])
j <- j + 1
}
i <- i + 1
}
count_df <- as.data.frame(from, stringsAsFactors = FALSE)
count_df <- rename(count_df, c("V1" = "from"))
count_df$to <- as.character(to)
count_df$fromNumber <- NA
count_df$toNumber <- NA
i <- 1
while (i <= nrow(count_df)){
j <- 1
while(j <= nrow(regierung_df)){
if (regierung_df$name[j] == count_df$to[i]){
count_df$toNumber[i] <- regierung_df$number[j]
}
j <- j + 1
}
i <- i + 1
}
i <- 1
while (i <= nrow(count_df)){
j <- 1
while(j <= nrow(regierung_df)){
if (regierung_df$name[j] == count_df$from[i]){
count_df$fromNumber[i] <- regierung_df$number[j]
}
j <- j + 1
}
i <- i + 1
}
### Performing the queries and counting
#Thirdly, we perform the actuall queries. We define the API Key. We paste the pairs in the count_df and use them as queries. We set the date to the current period of governance. We set the `limit = 1`, beacause we only intrested in the numbers which are found in the respective period. At last we set the system to sleep for half a second to be server kindly.
options(zeitApiKey = "40b65e34423ed6cb8d7f05914bbdaa1355f7c650caa8821e95b4")
count_df$count <- 0
i <- 1
while (i <= nrow(count_df)){
query = paste(count_df$from[i],
count_df$to[i], sep = " ")
articels <- fromZeit(q = query,
limit = "1",
dateBegin = "2013-02-17",
dateEnd = "2015-04-07")
count_df$count[i] <- count_df$count[i] + as.numeric(articels$found)
Sys.sleep(0.5)
i <- i + 1
}
#In a fourt part, we count the numbers of articles in which every minister is mentioned.
i <- 1
regierung_df$mentioned <- 0
while (i <= nrow(regierung_df)){
j <- 1
while (j <= nrow(count_df)){
regierung_df$mentioned[i] <- ifelse(count_df$from[j] == regierung_df$name[i],
regierung_df$mentioned[i] + count_df$count[j],
regierung_df$mentioned[i])
j <- j + 1
}
i <- i + 1
}
i <- 1
while (i <= nrow(regierung_df)){
j <- 1
while (j <= nrow(count_df)){
regierung_df$mentioned[i] <- ifelse(count_df$to[j] == regierung_df$name[i],
regierung_df$mentioned[i] + count_df$count[j],
regierung_df$mentioned[i])
j <- j + 1
}
i <- i + 1
}
regierung_df$mentioned <- round(regierung_df$mentioned / 100)
### Plot the network
#At last we plot the network. Minimize the connections to improve output quality.
sample <- count_df[count_df$count > mean(count_df$count), ]
forceNetwork(Links = sample,
Nodes = regierung_df,
Source = "fromNumber",
Target = "toNumber",
Value = "count",
NodeID = "name",
Group = "partei",
Nodesize = "mentioned",
linkDistance = JS("function(d){return d.value * 1.5}"),
linkWidth = JS("function(d){return d.value / 50}"),
opacity = 0.8,
width = 800,
height = 400,
legend = TRUE)
forceNetwork(Links = sample,
Nodes = regierung_df,
Source = "fromNumber",
Target = "toNumber",
Value = "count",
NodeID = "name",
Group = "partei",
Nodesize = "mentioned",
linkDistance = JS("function(d){return d.value * 1.5}"),
linkWidth = JS("function(d){return d.value / 50}"),
opacity = 0.8,
width = 400,
height = 200,
legend = TRUE)
forceNetwork(Links = sample,
Nodes = regierung_df,
Source = "fromNumber",
Target = "toNumber",
Value = "count",
NodeID = "name",
Group = "partei",
Nodesize = "mentioned",
linkDistance = JS("function(d){return d.value * 1.5}"),
linkWidth = JS("function(d){return d.value / 50}"),
opacity = 0.8,
width = 500,
height = 300,
legend = TRUE)
forceNetwork(Links = sample,
Nodes = regierung_df,
Source = "fromNumber",
Target = "toNumber",
Value = "count",
NodeID = "name",
Group = "partei",
Nodesize = "mentioned",
linkDistance = JS("function(d){return d.value * 1.5}"),
linkWidth = JS("function(d){return d.value / 50}"),
opacity = 0.8,
width = 500,
height = 300,
legend = TRUE)
?zeitPlot
?plotZeit
library(rzeit)
library(rzeit)
?zeitPlot
browseVignettes("rzeit")
browseVignettes("rzeit")
library(rzeit)
library(rzeit)
browseVignettes("rzeit")
?array
library(devtools)
install_github("tollpatsch/rzeit")
library(rzeit)
+
zeitSetApiKey
zeitSetApiKey("40b65e34423ed6cb8d7f05914bbdaa1355f7c650caa8821e95b4")
install_github("tollpatsch/rzeit")
library(devtools)
install_github("tollpatsch/rzeit")
library(rzeit)
devtools::install_github("tollpatsch/rzeit")
library(rzeit)
browseVignettes("rzeit")
load("C:/Users/Jan/AppData/Local/Temp/.RData")
devtools::install_github("tollpatsch/rzeit")
library(rzeit)
results_withoutSplit <- fromZeit(q = "Angela Merkel",
split = FALSE,
limit = "1000",
multipleTokens = TRUE,
dateBegin = "2013-01-01",
dateEnd = "2014-12-31")
results_withoutSplit <- zeitFrequencies(ls = results_withoutSplit,
sort = "month",
save = FALSE)
frequencies_withoutSplit <- results_withoutSplit
results_split <- fromZeit(q = "Angela Merkel",
split = TRUE,
limit = "1000",
multipleTokens = FALSE,
dateBegin = "2013-01-01",
dateEnd = "2014-12-31")
results_split <- zeitFrequencies(ls = results_split,
sort = "month",
save = FALSE)
frequencies_split <- results_split
par(mfrow=c(1, 2))
zeitPlot(frequencies_split, title = "with split", absolute = FALSE)
zeitPlot(frequencies_withoutSplit, title = "without split", absolute = FALSE)
par(mfrow=c(1, 1))
library(roxygen)
library(roxygen2)
library(rzeit)
test <- fromZeit("Merkel")
test <- fromZeit(q = "Merkel")
remove.packages("rzeit")
library(devtools)
install_github("tollpatsch/rzeit")
library(Rccp)
install.packages("Rcpp")
install_github("tollpatsch/rzeit")
library(devtools)
install_github("tollpatsch/rzeit")
library(rzeit)
fromZeit(p="Agela Merkel")
fromZeit(q ="Angela Merkel")
test <- fromZeit(q ="Angela Merkel", split = FALSE)
test <- fromZeit(q ="David Beckham", split = FALSE)
article <- zeitToDf(test, sort = "y")
View(article)
article <- zeitToDf(test, sort = "m")
article <- zeitToDf(test, sort = )
article <- zeitToDf(test, sort = d)
article <- zeitToDf(test, sort = "d")
article <- zeitFrequencies(test, sort = "d")
setwd("D:/OneDrive/Programming/GitHub/rzeit/vignettes")
buildVignettes(package, dir, lib.loc = NULL, quiet = TRUE,
clean = TRUE, tangle = FALSE)
