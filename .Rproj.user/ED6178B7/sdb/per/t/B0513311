{
    "contents" : "---\ntitle: \"Network Example with rzeit package\"\nauthor: \"Jana Blahak & Jan Dix\"\ndate: \"`r Sys.Date()`\"\noutput: rmarkdown::html_vignette\nvignette: >\n  %\\VignetteEngine{knitr::rmarkdown}\n  %\\VignetteEncoding{UTF-8}\n---\n\nThe `rzeit-package` is based on the Developer API by Zeit Online, a German newspaper portal.The package is the result of an university course, teaching the basic methods of web scraping. In first hand this package was planned as a smaller version to enable gathering big numbers of German newspaper articels to compare them to Google Trends. The following sections show how to design interactive networks with `rzeit-package` and `networkD3`. We will map the example network between the ministers of the current German government. We are using German ministers, as ZEIT ONLINE provides only news articles in German. We assume, that the numbers of articles mentioning a pair of ministers represent some kind of connectivity, either negativ or positiv. The network output will be based on the frequency of articles.   \n\n#### Loading Packages\n\nFirst we load all required packages:\n\n```{r basicconsole, warning = FALSE, results = \"hide\", message = FALSE}\nrequire(rzeit)\nrequire(XML)\nrequire(rvest)\nrequire(plyr)\nrequire(networkD3)\n```\n\n#### Gathering Data\n\nIn a first step, we gather informations on German ministers with Wikipedia. We then parse the page about the German government and create a data frame with name and party affiliation. In addition, every person is assigned a personal ID number.\n\n\n```{r Gathering Data from Wikipedia, eval = FALSE}\n\n### Take the table of mps----\ngovernment_url <- \"https://de.wikipedia.org/wiki/Bundesregierung_%28Deutschland%29\"\ngovernment_parsed <- html(government_url, encoding = \"UTF8\")\n\n### read the table\ngovernment_tables <- readHTMLTable(government_parsed)\ngovernment_df <- government_tables[[1]]\n\ngovernment_df <- rename(government_df,\n                        c(\"Amtsinhaber\" = \"name\"))\ngovernment_df <- rename(government_df,\n                        c(\"Partei\" = \"party\"))\n\n\ngovernment_df$name <- as.character(government_df$name)\ngovernment_df$partei <- as.character(government_df$party)\ngovernment_df$number <- 0:15\n\ngovernment_df <- government_df[, -1]\ngovernment_df <- government_df[, -1]\n```\n\n\nWe then build a second data frame with pairs of every name.\nThis data frame will provide our queries for the `fromZeit`-function. Furthermore, we copy the corresponding ID numbers. This will be very important in the further steps. \n\n```{r Query data frame, eval = FALSE}\ni <- 1\nfrom <- NULL\nto <- NULL\n\nwhile (i <= nrow(government_df)){\n  j <- i + 1\n  while (j <= nrow(government_df)){\n    from <- rbind(from, government_df$name[i])\n    to <- rbind(to, government_df$name[j])\n    j <- j + 1\n  }\n  i <- i + 1\n}\n\n\ncount_df <- as.data.frame(from, stringsAsFactors = FALSE)\ncount_df <- rename(count_df, c(\"V1\" = \"from\"))\ncount_df$to <- as.character(to)\n\ncount_df$fromNumber <- NA\ncount_df$toNumber <- NA\n\ni <- 1\nwhile (i <= nrow(count_df)){\n  j <- 1\n  while(j <= nrow(government_df)){  \n    if (government_df$name[j] == count_df$to[i]){\n      count_df$toNumber[i] <- government_df$number[j]\n    }\n    j <- j + 1\n  }\n  i <- i + 1\n}\n\ni <- 1\nwhile (i <= nrow(count_df)){\n  j <- 1\n  while(j <= nrow(government_df)){  \n    if (government_df$name[j] == count_df$from[i]){\n      count_df$fromNumber[i] <- government_df$number[j]\n    }\n    j <- j + 1\n  }\n  i <- i + 1\n}\n\n```\n\n### Performing the queries and counting\n\nThirdly, we perform the actual queries. At the beginning the API Key is defined. We then paste the pairs created before into the count_df and use them as queries. Afterwards, the date is set to the current period of government. The limit is set `limit = 1`, because we are only interested in the numbers found in the respective period. At last the system is set to sleep for half a second, as this is more server-friendly. \n\n```{r Perform queries, eval = FALSE}\nzeitSetApiKey(\"set_your_api_key_here\")\n\ncount_df$count <- 0\ni <- 1\n\nwhile (i <= nrow(count_df)){\n  query = paste(count_df$from[i], \n                count_df$to[i], sep = \" \")\n  articels <- fromZeit(q = query, \n                       limit = \"1\", \n                       dateBegin = \"2013-02-17\", \n                       dateEnd = \"2014-12-31\")\n  count_df$count[i] <- count_df$count[i] + as.numeric(articels$found)\n  Sys.sleep(0.5)\n  i <- i + 1\n}\n```\n\nIn a fourth part, we count the numbers of articles, in which the name of a minister is mentioned.\n\n```{r Counting, eval = FALSE}\ni <- 1\ngovernment_df$mentioned <- 0\n\nwhile (i <= nrow(government_df)){\n  j <- 1\n  while (j <= nrow(count_df)){\n    government_df$mentioned[i] <- ifelse(count_df$from[j] == government_df$name[i],\n                                         government_df$mentioned[i] + count_df$count[j],\n                                         government_df$mentioned[i]) \n    \n    j <- j + 1\n  }\n  i <- i + 1\n}\n\ni <- 1\n\nwhile (i <= nrow(government_df)){\n  j <- 1\n  while (j <= nrow(count_df)){\n    government_df$mentioned[i] <- ifelse(count_df$to[j] == government_df$name[i],\n                                         government_df$mentioned[i] + count_df$count[j],\n                                         government_df$mentioned[i]) \n    \n    j <- j + 1\n  }\n  i <- i + 1\n}\n```\n\nFor aesthetic reasons we rescale the `mentioned`-variable.\n\n```{r corrections 1, eval = FALSE}\ngovernment_df$mentioned <- round(government_df$mentioned / max(government_df$mentioned) * 500)\n```\n\n```{r loading data sets, echo = FALSE}\nload(\"df/count_df.Rda\")\nload(\"df/government_df.Rda\")\n```\n### Plot the network\n\nBecause the code requires an API Key, we load prepared data frames in the background. This data frames are built by the previous code and include all required data.\n\n```{r}\nhead(count_df)\nhead(government_df)\n```\n\nBefore we plot the network, we devide the `count_df` into the `sample data frame`, excluding all connections which are less than the mean of connections. This due to aesthetic resaons again.\n\n```{r corrections 2}\nsample <- count_df[count_df$count > mean(count_df$count), ]\n```\n\nAt last we plot the network. The number of shared articles define the strength of the edges. The node size is defined by total numbers of mentions. Unfortunately, the parties cannot be painted in their original colors, because the `networkD3` - package does not provide individual color settings. \n\n\n```{r Plot network}\nsample <- count_df[count_df$count > mean(count_df$count), ]\n\nforceNetwork(Links = sample,\n             Nodes = government_df,\n             Source = \"fromNumber\",\n             Target = \"toNumber\",\n             Value = \"count\",\n             NodeID = \"name\",\n             Group = \"party\",\n             Nodesize = \"mentioned\",\n             linkDistance = JS(\"function(d){return d.value}\"),\n             linkWidth = JS(\"function(d){return d.value / 50}\"),\n             opacity = 0.8,\n             width = 800,\n             height = 400,\n             legend = TRUE,\n             colourScale = \n             JS('d3.scale.ordinal()\n                .domain([\"SPD\", \"CSU\",\"CDU\"])\n                .range([\"#e1001a\", \"#007dbd\" , \"#e95d0f\"]);'),)\n\n```\n",
    "created" : 1437573987456.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "177266321",
    "id" : "B0513311",
    "lastKnownWriteTime" : 1437574108,
    "path" : "D:/rzeit-master/rzeit-master/vignettes/rzeit_network.Rmd",
    "project_path" : "vignettes/rzeit_network.Rmd",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "type" : "r_markdown"
}