---
title: "Network Example with rzeit package"
author: "Jana Blahak & Jan Dix"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

The `rzeit-package` is based on the Developer API by Zeit Online, a German newspaper portal.The package is the result of an university course, teaching the basic methods of web scraping. In first hand this package was planned as a smaller version to enable gathering big numbers of German newspaper articels to compare them to Google Trends. The following sections show how to design interactive networks with `rzeit-package` and `networkD3`. We will map the example network between the ministers of the current German government. We are using German ministers, as ZEIT ONLINE provides only news articles in German. We assume, that the numbers of articles mentioning a pair of ministers represent some kind of connectivity, either negativ or positiv. The network output will be based on the frequency of articles.   

#### Loading Packages

First we load all required packages:

```{r basicconsole, warning = FALSE, results = "hide", message = FALSE}
require(rzeit)
require(XML)
require(rvest)
require(plyr)
require(networkD3)
```

#### Gathering Data

In a first step, we gather informations on German ministers with Wikipedia. We then parse the page about the German government and create a data frame with name and party affiliation. In addition, every person is assigned a personal ID number.


```{r Gathering Data from Wikipedia, eval = FALSE}

### Take the table of mps----
government_url <- "https://de.wikipedia.org/wiki/Bundesregierung_%28Deutschland%29"
government_parsed <- html(government_url, encoding = "UTF8")

### read the table
government_tables <- readHTMLTable(government_parsed)
government_df <- government_tables[[1]]

government_df <- rename(government_df,
                        c("Amtsinhaber" = "name"))
government_df <- rename(government_df,
                        c("Partei" = "party"))


government_df$name <- as.character(government_df$name)
government_df$partei <- as.character(government_df$party)
government_df$number <- 0:15

government_df <- government_df[, -1]
government_df <- government_df[, -1]
```


We then build a second data frame with pairs of every name.
This data frame will provide our queries for the `fromZeit`-function. Furthermore, we copy the corresponding ID numbers. This will be very important in the further steps. 

```{r Query data frame, eval = FALSE}
i <- 1
from <- NULL
to <- NULL

while (i <= nrow(government_df)){
  j <- i + 1
  while (j <= nrow(government_df)){
    from <- rbind(from, government_df$name[i])
    to <- rbind(to, government_df$name[j])
    j <- j + 1
  }
  i <- i + 1
}


count_df <- as.data.frame(from, stringsAsFactors = FALSE)
count_df <- rename(count_df, c("V1" = "from"))
count_df$to <- as.character(to)

count_df$fromNumber <- NA
count_df$toNumber <- NA

i <- 1
while (i <= nrow(count_df)){
  j <- 1
  while(j <= nrow(government_df)){  
    if (government_df$name[j] == count_df$to[i]){
      count_df$toNumber[i] <- government_df$number[j]
    }
    j <- j + 1
  }
  i <- i + 1
}

i <- 1
while (i <= nrow(count_df)){
  j <- 1
  while(j <= nrow(government_df)){  
    if (government_df$name[j] == count_df$from[i]){
      count_df$fromNumber[i] <- government_df$number[j]
    }
    j <- j + 1
  }
  i <- i + 1
}

```

### Performing the queries and counting

Thirdly, we perform the actual queries. At the beginning the API Key is defined. We then paste the pairs created before into the count_df and use them as queries. Afterwards, the date is set to the current period of government. The limit is set `limit = 1`, because we are only interested in the numbers found in the respective period. At last the system is set to sleep for half a second, as this is more server-friendly. 

```{r Perform queries, eval = FALSE}
zeitSetApiKey("set_your_api_key_here")

count_df$count <- 0
i <- 1

while (i <= nrow(count_df)){
  query = paste(count_df$from[i], 
                count_df$to[i], sep = " ")
  articels <- fromZeit(q = query, 
                       limit = "1", 
                       dateBegin = "2013-02-17", 
                       dateEnd = "2014-12-31")
  count_df$count[i] <- count_df$count[i] + as.numeric(articels$found)
  Sys.sleep(0.5)
  i <- i + 1
}
```

In a fourth part, we count the numbers of articles, in which the name of a minister is mentioned.

```{r Counting, eval = FALSE}
i <- 1
government_df$mentioned <- 0

while (i <= nrow(government_df)){
  j <- 1
  while (j <= nrow(count_df)){
    government_df$mentioned[i] <- ifelse(count_df$from[j] == government_df$name[i],
                                         government_df$mentioned[i] + count_df$count[j],
                                         government_df$mentioned[i]) 
    
    j <- j + 1
  }
  i <- i + 1
}

i <- 1

while (i <= nrow(government_df)){
  j <- 1
  while (j <= nrow(count_df)){
    government_df$mentioned[i] <- ifelse(count_df$to[j] == government_df$name[i],
                                         government_df$mentioned[i] + count_df$count[j],
                                         government_df$mentioned[i]) 
    
    j <- j + 1
  }
  i <- i + 1
}
```

For aesthetic reasons we rescale the `mentioned`-variable.

```{r corrections 1, eval = FALSE}
government_df$mentioned <- round(government_df$mentioned / max(government_df$mentioned) * 500)
```

```{r loading data sets, echo = FALSE}
load("df/count_df.Rda")
load("df/government_df.Rda")
```
### Plot the network

Because the code requires an API Key, we load prepared data frames in the background. This data frames are built by the previous code and include all required data.

```{r}
head(count_df)
head(government_df)
```

Before we plot the network, we devide the `count_df` into the `sample data frame`, excluding all connections which are less than the mean of connections. This due to aesthetic resaons again.

```{r corrections 2}
sample <- count_df[count_df$count > mean(count_df$count), ]
```

At last we plot the network. The number of shared articles define the strength of the edges. The node size is defined by total numbers of mentions. Unfortunately, the parties cannot be painted in their original colors, because the `networkD3` - package does not provide individual color settings. 


```{r Plot network}
sample <- count_df[count_df$count > mean(count_df$count), ]

forceNetwork(Links = sample,
             Nodes = government_df,
             Source = "fromNumber",
             Target = "toNumber",
             Value = "count",
             NodeID = "name",
             Group = "party",
             Nodesize = "mentioned",
             linkDistance = JS("function(d){return d.value}"),
             linkWidth = JS("function(d){return d.value / 50}"),
             opacity = 0.8,
             width = 800,
             height = 400,
             legend = TRUE,
             colourScale = 
             JS('d3.scale.ordinal()
                .domain(["SPD", "CSU","CDU"])
                .range(["#e1001a", "#007dbd" , "#e95d0f"]);'),)

```
